#!/usr/bin/env python3
"""
Deterministic codegen for Calendar Planner workflow.

Reads workflow/workflow.json and emits runtime/graph_compiled.py with:
- Byte-identical output for unchanged schema (no timestamps)
- Sorted imports, nodes, edges
- Stubs resolved to runtime.nodes_stubs when implementation isn't found

Absolute invariants:
- Only writes under /runtime/*
"""
import hashlib
import json
from pathlib import Path
from typing import Dict, Any, List

ROOT = Path(__file__).resolve().parents[1]
SCHEMA_PATH = ROOT / "workflow" / "workflow.json"
RUNTIME_DIR = ROOT / "runtime"
COMPILED = RUNTIME_DIR / "graph_compiled.py"
STUBS = RUNTIME_DIR / "nodes_stubs.py"


def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()


def load_schema() -> Dict[str, Any]:
    data = json.loads(SCHEMA_PATH.read_text())
    # Normalize: sort nodes by id, edges by (from,to,condition)
    data["nodes"] = sorted(data.get("nodes", []), key=lambda n: str(n.get("id")))
    data["edges"] = sorted(
        data.get("edges", []), key=lambda e: (str(e.get("from")), str(e.get("to")), str(e.get("condition")))
    )
    # Sort state keys
    if isinstance(data.get("state"), dict):
        data["state"] = {k: data["state"][k] for k in sorted(data["state"].keys())}
    return data


def discover_impl(node: Dict[str, Any]) -> str:
    """Return dotted path for node implementation.
    For now, map 'python_fn' and unknown types to runtime.nodes_stubs:{id}
    """
    node_id = str(node.get("id"))
    t = node.get("type")
    if t in {"agent", "tool"} and node.get("impl"):
        return str(node["impl"])  # user-provided dotted path
    return f"runtime.nodes_stubs:{node_id}"


def ensure_stubs(nodes: List[Dict[str, Any]]):
    RUNTIME_DIR.mkdir(parents=True, exist_ok=True)
    existing = STUBS.read_text().splitlines() if STUBS.exists() else []
    have = set()
    for line in existing:
        if line.startswith("def "):
            fname = line.split("def ", 1)[1].split("(", 1)[0].strip()
            have.add(fname)
    needed = []
    for n in nodes:
        fn = str(n.get("id"))
        if fn.isidentifier() and fn not in have:
            needed.append(fn)
    if not STUBS.exists():
        header = """# Auto-generated stubs (safe to edit/extend)
from typing import Dict, Any

def _ctx_update(ctx: Dict[str, Any], **kw):
    ctx.update(kw); return ctx
"""
        STUBS.write_text(header)
        existing = STUBS.read_text()
    # Append needed functions deterministically
    if needed:
        with STUBS.open("a") as f:
            for fn in sorted(needed):
                f.write(
                "\n\n"
                + f"def {fn}(state: Dict[str, Any]) -> Dict[str, Any]:\n"
                + f"    \"\"\"Stub for node '{fn}'. Replace with real implementation.\n\n"
                + "    Returns possibly updated state.\n\n\"\"\"\n"
                + "    return state\n"
                )


def compile_graph(schema: Dict[str, Any]) -> str:
    schema_hash = sha256_bytes(json.dumps(schema, separators=(",", ":")).encode("utf-8"))
    nodes = schema.get("nodes", [])
    edges = schema.get("edges", [])
    ensure_stubs(nodes)
    # Build imports and registry
    imports = ["from typing import Dict, Any\n", "import importlib\n"]
    # Dotted paths map
    registry = {str(n.get("id")): discover_impl(n) for n in nodes}
    # Build text deterministically
    lines = []
    lines.append("# Generated by tools/codegen.py\n")
    lines.append(f"SCHEMA_HASH = '{schema_hash}'\n")
    lines.append("\n")
    lines.extend(imports)
    lines.append("\n")
    # registry
    lines.append("REGISTRY = {\n")
    for k in sorted(registry.keys()):
        lines.append(f"    '{k}': '{registry[k]}',\n")
    lines.append("}\n\n")
    # edges
    lines.append("EDGES = [\n")
    for e in edges:
        fr, to, cond = str(e.get("from")), str(e.get("to")), e.get("condition")
        if cond is None:
            cond_repr = "None"
        else:
            # serialize string with quotes, else fallback to str
            cond_repr = json.dumps(cond) if isinstance(cond, str) else repr(cond)
        lines.append(f"    ('{fr}', '{to}', {cond_repr}),\n")
    lines.append("]\n\n")
    # runner
    lines.append(
        "def _resolve(dotted: str):\n"
        "    mod, fn = dotted.split(':', 1)\n"
        "    m = importlib.import_module(mod)\n"
        "    return getattr(m, fn)\n\n"
    )
    lines.append(
        "def run(state: Dict[str, Any]) -> Dict[str, Any]:\n"
        "    current = state.get('start', REGISTRY and sorted(REGISTRY.keys())[0])\n"
        "    visited = []\n"
        "    while current:\n"
        "        visited.append(current)\n"
        "        fn = _resolve(REGISTRY[current])\n"
        "        state = fn(state)\n"
        "        # pick next edge by first matching condition or first edge\n"
        "        nxt = None\n"
        "        for fr,to,cond in EDGES:\n"
        "            if fr != current: continue\n"
        "            if cond is None: nxt = to; break\n"
        "            try:\n"
        "                # Expose state dict as name 'state' only\n"
        "                if eval(cond, {'__builtins__':{}}, {'state': state}):\n"
        "                    nxt = to; break\n"
        "            except Exception:\n"
        "                continue\n"
        "        current = nxt\n"
        "    state['visited'] = visited\n"
        "    return state\n"
    )
    return "".join(lines)


def main():
    schema = load_schema()
    out = compile_graph(schema)
    RUNTIME_DIR.mkdir(parents=True, exist_ok=True)
    COMPILED.write_text(out)
    print("SCHEMA_HASH:", sha256_bytes(json.dumps(schema, separators=(",", ":")).encode("utf-8")))
    print("WROTE:", COMPILED)


if __name__ == "__main__":
    main()
