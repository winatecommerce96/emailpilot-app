"""
Generated LangGraph Runtime
Generated at: GENERATED
Schema: emailpilot_calendar v0.2.0

DO NOT EDIT - This file is generated by tools/codegen.py
"""

import logging
from typing import Dict, Any, List, TypedDict, Optional, Union
from datetime import datetime
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from langgraph.checkpoint.memory import MemorySaver
from workflow.tools.safe_eval import evaluate_condition

logger = logging.getLogger(__name__)

# State definition
class GraphState(TypedDict):
    """State for the emailpilot_calendar workflow"""
    brand: str
    month: str
    inputs: Dict[str, Any]
    candidates: List[Dict[str, Any]]
    calendar: Dict[str, Any]
    valid: bool
    approvals: Dict[str, Any]
    errors: List[str]
    run_id: str
    user_id: Optional[str]
    cache_enabled: bool

# Node imports
from workflow.nodes.ingest import run
from workflow.agents.calendar_planner import create
from workflow.pipelines.rules import validate_pipeline
from workflow.nodes.human_review import run
from workflow.nodes.publish import run

# Node implementations

def ingest_node(state: GraphState) -> GraphState:
    """Node: ingest (python_fn)"""
    try:
        state["_node_params"] = {'timeout': 30, 'retries': 2, 'validation': 'strict'}
        
        from workflow.nodes.ingest import run
        result = run(state)
        
        if "_node_params" in result:
            del result["_node_params"]
        return result
        
    except Exception as e:
        logger.error(f"Error in ingest: {e}")
        raise

def generate_node(state: GraphState) -> GraphState:
    """Node: generate (agent)"""
    try:
        # Store params in state for node to access
        state["_node_params"] = {'tool_allowlist': ['tools.klaviyo_campaigns', 'tools.klaviyo_segments', 'tools.firestore_ro', 'tools.calculate', 'tools.generate_campaign_ideas'], 'max_tool_calls': 20, 'timeout': 120, 'model': 'gpt-4-turbo-preview', 'temperature': 0.7}
        
        # Import and create agent
        module_path = "agents.calendar_planner:create"
        if ":" in module_path:
            module, func = module_path.rsplit(":", 1)
            exec(f"from workflow.{module} import {func}")
            agent = eval(f"{func}({'tool_allowlist': ['tools.klaviyo_campaigns', 'tools.klaviyo_segments', 'tools.firestore_ro', 'tools.calculate', 'tools.generate_campaign_ideas'], 'max_tool_calls': 20, 'timeout': 120, 'model': 'gpt-4-turbo-preview', 'temperature': 0.7})")
        else:
            from workflow.agents.calendar_planner:create import create
            agent = create({'tool_allowlist': ['tools.klaviyo_campaigns', 'tools.klaviyo_segments', 'tools.firestore_ro', 'tools.calculate', 'tools.generate_campaign_ideas'], 'max_tool_calls': 20, 'timeout': 120, 'model': 'gpt-4-turbo-preview', 'temperature': 0.7})
        
        # Execute agent
        result = agent.invoke(state)
        
        # Clean up params
        if "_node_params" in result:
            del result["_node_params"]
        
        return result
        
    except Exception as e:
        logger.error(f"Error in generate: {e}")
        if "generate" in []:
            logger.warning(f"Using stub for generate")
            from workflow.runtime.nodes_stubs import generate_stub
            return generate_stub(state)
        raise

def validate_node(state: GraphState) -> GraphState:
    """Node: validate (python_fn)"""
    try:
        state["_node_params"] = {'rules': {'min_campaigns': 20, 'min_sms': 4, 'max_weekly_sends': 2, 'revenue_distribution': {'two_segments': {'primary': 70, 'secondary': 30}, 'three_segments': {'primary': 70, 'secondary': 15, 'tertiary': 15}}}, 'strict': True}
        
        from workflow.pipelines.rules import validate_pipeline
        result = validate_pipeline(state)
        
        if "_node_params" in result:
            del result["_node_params"]
        return result
        
    except Exception as e:
        logger.error(f"Error in validate: {e}")
        raise

def review_node(state: GraphState) -> GraphState:
    """Node: review (human gate)"""
    try:
        state["_node_params"] = {'preview_format': 'json', 'timeout': 3600, 'notification': 'slack'}
        
        if "nodes.human_review:run":
            module, func = "nodes.human_review:run".rsplit(":", 1)
            from workflow.nodes.human_review import run
            result = run(state)
        else:
            # Default human gate implementation
            import json
            print("\n" + "="*60)
            print("ğŸ›‘ HUMAN REVIEW REQUIRED")
            print("="*60)
            print(json.dumps({k: v for k, v in state.items() if k != "inputs"}, indent=2, default=str))
            
            response = input("\nApprove? (yes/no): ").strip().lower()
            state["approvals"] = {
                "approved": response == "yes",
                "timestamp": datetime.now().isoformat(),
                "notes": response if response not in ["yes", "no"] else ""
            }
            result = state
        
        if "_node_params" in result:
            del result["_node_params"]
        return result
        
    except Exception as e:
        logger.error(f"Error in review: {e}")
        raise

def publish_node(state: GraphState) -> GraphState:
    """Node: publish (python_fn)"""
    try:
        state["_node_params"] = {'target': 'firestore', 'collection': 'calendars', 'backup': True}
        
        from workflow.nodes.publish import run
        result = run(state)
        
        if "_node_params" in result:
            del result["_node_params"]
        return result
        
    except Exception as e:
        logger.error(f"Error in publish: {e}")
        raise

# Graph builder
def compile_graph() -> StateGraph:
    """Compile the emailpilot_calendar workflow"""
    
    # Create graph
    graph = StateGraph(GraphState)
    
    # Add nodes
    graph.add_node("ingest", ingest_node)
    graph.add_node("generate", generate_node)
    graph.add_node("validate", validate_node)
    graph.add_node("review", review_node)
    graph.add_node("publish", publish_node)
    
    # Add edges
    graph.add_edge("ingest", "generate")
    graph.add_edge("generate", "validate")
    graph.add_edge("review", "publish")
    
    # Add conditional edges

    def route_validate(state: GraphState) -> str:
        """Router for validate"""
        if evaluate_condition("state.get('valid', False)", state):
            return "review"
        elif evaluate_condition("not state.get('valid', False)", state):
            return "generate"
        return END    graph.add_conditional_edges("validate", route_validate)
    
    # Set entry point
    graph.set_entry_point("ingest")
    
    # Setup checkpointer

    # SQLite checkpointer
    checkpointer = SqliteSaver.from_conn_string("sqlite:///emailpilot_workflow.db")
    
    # Compile
    app = graph.compile(checkpointer=checkpointer)
    
    return app

# Export
__all__ = ["compile_graph", "GraphState", "run_workflow"]

def run_workflow(inputs: Dict[str, Any], config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """Convenience function to run the workflow"""
    app = compile_graph()
    # Build initial state with sorted keys for determinism
    initial_state = {
        "run_id": inputs.get("run_id", ""),
        "user_id": inputs.get("user_id"),
        "inputs": inputs
    }
    # Add remaining inputs in sorted order
    for key in sorted(inputs.keys()):
        if key not in ["run_id", "user_id", "inputs"]:
            initial_state[key] = inputs[key]
    return app.invoke(initial_state, config=config or {})
